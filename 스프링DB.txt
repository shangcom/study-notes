** Connection : JDBC에서 데이터베이스와 애플리케이션 간의 실제 연결을 나타내는 객체
데이터베이스 연결 유지
Connection 객체는 애플리케이션이 데이터베이스에 연결하고 이를 유지하는 역할을 합니다.
연결이 설정되면 Connection을 통해 SQL 쿼리를 데이터베이스에 전달할 수 있습니다.

SQL 쿼리 실행
Connection 객체는 SQL 쿼리를 실행하는 데 필요한 **Statement, PreparedStatement, CallableStatement**와 같은 객체를 생성할 수 있습니다.
이러한 객체들은 Connection을 통해 데이터베이스와 통신하며 쿼리를 실행합니다.

트랜잭션 관리
Connection 객체는 데이터베이스 트랜잭션을 관리할 수 있는 기능을 제공합니다.
기본적으로 자동 커밋이 활성화되어 있지만, 이를 비활성화하고 수동으로 commit()이나 rollback() 메서드를 호출하여 트랜잭션의 일관성을 유지할 수 있습니다.

리소스 관리
Connection 객체는 데이터베이스 자원을 효율적으로 사용하는 데 중요한 역할을 합니다.
Connection을 다 사용한 후 close() 메서드를 호출해주어야 합니다. Connection Pool을 사용할 때는 close() 호출 시 실제로 연결이 닫히지 않고 풀에 반환됩니다.


** DriverManager:
데이터베이스 드라이버를 관리하고, 새로운 커넥션을 생성하는 전통적 방식입니다.
커넥션 풀을 사용하지 않고 매번 새 커넥션을 만듭니다.
현재는 DataSource 내부에서 최초 커넥션 설정 시에만 주로 사용됩니다.

** DataSource:
데이터베이스 연결을 위한 표준 인터페이스로, 커넥션 풀을 통해 다수의 연결을 효율적으로 관리할 수 있는 기능을 제공합니다.
대부분의 DataSource 구현체는 내부에 커넥션 풀을 포함하고 있으며, 필요 시 DriverManager를 통해 최초 커넥션을 설정합니다.

** Connection Pool:
미리 생성된 커넥션을 보관하고 재사용하여, 애플리케이션이 데이터베이스와 연결할 때 성능을 최적화합니다.
DataSource 구현체 내부에 포함되어 있어, 연결 요청 시 커넥션 풀에서 사용 가능한 커넥션을 반환하고, 사용이 끝난 커넥션을 다시 풀에 반환합니다.



1. 커넥션 풀 = 전화 교환원
커넥션 풀은 전화 교환원과 같습니다. 교환원이 미리 여러 **전화선(커넥션)**을 준비해 놓고, 누군가 통화를 원할 때마다 전화선을 배정해 줍니다.
통화가 끝나면 **전화선(커넥션)**을 완전히 끊는 것이 아니라, 다시 교환원에게 반환하여 다른 사람이 사용할 수 있게 합니다.
2. 커넥션 = 전화선
커넥션은 전화선입니다. 교환원이 할당해 준 전화선이 연결되어야만 **대화(세션)**를 시작할 수 있습니다.
3. 세션 = 대화
세션은 전화선을 통해 나누는 대화입니다. 전화선이 연결된 동안 대화를 나누며, 대화가 끝나면 전화선을 교환원에게 돌려줍니다.
4. 트랜잭션 = 대화 중 특정 주제
트랜잭션은 대화 중에 나누는 특정 주제로, 완료되면 확정(커밋)되거나 취소(롤백)됩니다.


** 커넥션풀과 데이터소스

1. JDBC와 커넥션 관리
DriverManager: JDBC 드라이버를 통해 매번 새로운 커넥션을 생성하는 방식. 성능상의 부담이 있을 수 있으며, 커넥션 풀링을 지원하지 않음.
DataSource: 커넥션 풀링을 사용할 수 있는 인터페이스. DriverManagerDataSource는 매번 새로운 커넥션을 생성하지만, HikariCP 같은 커넥션 풀 구현체를 사용하면 커넥션을 미리 생성해 재사용 가능.
커넥션 풀 (Connection Pool): HikariCP 같은 풀을 사용하면 커넥션을 미리 만들어두고, 요청이 들어올 때 재사용하므로 성능과 자원 관리를 향상시킬 수 있음.
JdbcUtils: 커넥션, Statement, ResultSet 같은 자원을 안전하게 닫아주는 Spring 유틸리티. 자원 해제 코드가 간결해지고 안전해짐.

2. CRUD 작업과 커넥션 재사용
CRUD 작업: save, findById, update, delete를 사용하여 데이터베이스의 데이터를 읽고, 쓰고, 수정하고, 삭제하는 작업. 각 작업마다 커넥션을 얻어 DB와 상호작용.
커넥션 관리: 커넥션 풀을 사용하지 않으면 각 작업마다 새로운 커넥션을 열고 닫지만, 커넥션 풀을 사용하면 커넥션을 재사용하므로 성능이 향상됨.

3. HikariCP를 통한 커넥션 풀 적용
HikariCP: 성능이 뛰어난 커넥션 풀 구현체. 커넥션을 미리 만들어두고, 사용 후 풀로 반환하여 재사용하는 방식으로 커넥션을 효율적으로 관리.
커넥션 반환: close() 메서드를 통해 커넥션이 풀로 반환되고, 다른 요청에서 재사용될 수 있음. 실제로 커넥션이 닫히는 것은 아님.

**DataSource와 Connection Pool의 관계
Connection Pool은 커넥션을 미리 만들어 관리하는 방식이고, DataSource는 커넥션을 얻는 인터페이스입니다. 
대부분의 커넥션 풀 라이브러리(HikariCP, C3P0, DBCP)는 DataSource 인터페이스를 구현하여, 애플리케이션이 커넥션 풀을 쉽게 사용할 수 있게 합니다.
예를 들어, HikariCP를 사용하는 경우 HikariDataSource는 DataSource를 구현한 커넥션 풀입니다.




**트랜잭션 이해

트랜잭션(Transaction)
원자성(Atomicity): 트랜잭션 내의 모든 작업이 전부 성공하거나 전부 실패해야 한다는 개념(원자처럼 땅땅하게 깨지지 않아야 한다는 비유)
일관성(Consistency): 트랜잭션이 실행된 후 데이터베이스가 일관된 상태를 유지해야 함. ex) DB에서 정한 무결성 제약 조건을 항상 만족
격리성(Isolation): 여러 트랜잭션이 동시에 실행될 때 서로의 작업에 영향을 주지 않도록 격리해야 함.
지속성(Durability): 트랜잭션이 완료되면 그 결과는 영구적으로 데이터베이스에 반영되어야 함.

트랜잭션 관리
Commit: 트랜잭션 내의 모든 작업이 성공했을 때, 데이터베이스에 반영하는 명령.
Rollback: 트랜잭션 중 오류가 발생했을 때, 모든 변경 사항을 원래 상태로 되돌리는 명령.
Auto-commit 모드: 기본적으로 JDBC는 자동으로 커밋을 수행하지만, 트랜잭션을 수동으로 관리하려면 이를 비활성화하고 명시적으로 커밋이나 롤백을 수행해야 함.

트랜잭션 격리 수준(Isolation Level) : 엄격할 수록 속도 느려진다. 동시성 처리(concurrency)에 부하가 생기기 때문.
READ UNCOMMITTED: 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있음(Dirty Read).
READ COMMITTED: 커밋된 데이터만 읽을 수 있음.
REPEATABLE READ: 트랜잭션이 시작된 이후 읽은 데이터가 변경되지 않도록 보장.
SERIALIZABLE: 가장 엄격한 격리 수준으로, 모든 트랜잭션이 순차적으로 실행되도록 보장.



** TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
스프링의 트랜잭션 관리를 시작하는 코드.
트랜잭션은 하나의 비즈니스 로직 단위(즉, 서비스 메서드 단위)로 관리하는 것이 일반적
하나의 서비스 메서드가 여러 개의 데이터베이스 작업(읽기, 쓰기, 업데이트, 삭제)을 수행할 경우, 이 모든 작업이 하나의 트랜잭션 내에서 처리됩니다. 이 방식은 **원자성(Atomicity)**을 보장하여,
모든 작업이 성공하면 커밋되고, 도중에 하나라도 실패하면 롤백되는 방식으로 데이터의 일관성을 유지
전체 물리적 트랜잭션에 대한 별도의 TransactionStatus 객체가 존재하지 않습니다.
대신, 각 논리 트랜잭션마다 생성된 TransactionStatus 객체가 물리적 트랜잭션의 상태를 반영하고 관리하는 방식으로 동작.


1. transactionManager.getTransaction()
transactionManager는 스프링의 트랜잭션 관리 인터페이스인 PlatformTransactionManager의 구현체입니다. 이 메서드를 호출함으로써 트랜잭션을 시작할 수 있습니다.
getTransaction() 메서드는 새로운 트랜잭션을 시작하거나, 현재 이미 진행 중인 트랜잭션이 있으면 그 트랜잭션을 재사용합니다.
트랜잭션이 시작되면, 트랜잭션의 상태를 관리하는 객체인 TransactionStatus가 반환됩니다. 이 객체는 트랜잭션을 커밋하거나 롤백할 때 사용됩니다.

2. new DefaultTransactionDefinition()
DefaultTransactionDefinition은 트랜잭션의 기본 설정을 정의하는 객체입니다.
이 객체는 트랜잭션의 격리 수준, 전파 수준, 읽기 전용 여부와 같은 설정들을 기본값으로 설정합니다.
격리 수준: 트랜잭션이 다른 트랜잭션과 어떻게 상호작용할지를 결정합니다. 기본값은 ISOLATION_DEFAULT로, DBMS에 의해 기본 설정이 적용됩니다.
전파 수준: 현재 트랜잭션이 없으면 새로 생성하고, 이미 트랜잭션이 있으면 그 트랜잭션에 참여하는 방식입니다. 기본값은 PROPAGATION_REQUIRED로 설정됩니다.
타임아웃: 트랜잭션이 특정 시간 안에 완료되지 않으면 실패하도록 설정할 수 있습니다.
읽기 전용 여부: 트랜잭션이 읽기 전용인지 여부를 설정할 수 있으며, 기본값은 읽기와 쓰기가 모두 허용됩니다.

전체 흐름:
new DefaultTransactionDefinition(): 기본 트랜잭션 설정(격리 수준, 전파 수준 등)을 정의합니다.
transactionManager.getTransaction(): 이 설정을 기반으로 새로운 트랜잭션을 시작하거나, 기존 트랜잭션을 가져옵니다.
TransactionStatus: 트랜잭션의 상태를 관리하는 객체로, 이 객체를 통해 트랜잭션을 커밋하거나 롤백할 수 있습니다.

트랜잭션의 시작과 흐름:
이 코드는 트랜잭션을 시작하는 첫 단계입니다.
트랜잭션이 시작되면, 이후 코드에서 비즈니스 로직을 처리하고, 성공적으로 완료되면 transactionManager.commit(status)로 트랜잭션을 커밋하거나, 오류 발생 시 transactionManager.rollback(status)로 롤백합니다.



ThreadLocal
멀티스레드 환경에서 각각의 쓰레드가 독립적으로 변수를 가질 수 있도록 도와주는 자바의 클래스입니다.
즉, 같은 변수라도 각 쓰레드마다 다른 값을 가질 수 있게 해주는 기능을 제공하는 것이죠. 이를 통해 각 스레드는 자신만의 데이터를 다른 스레드와 공유하지 않고 독립적으로 관리할 수 있습니다.
일반적인 상황에서는 여러 스레드가 동일한 변수를 공유하면 동시성 문제가 발생할 수 있습니다. 하지만 ThreadLocal을 사용하면 각 스레드가 자신만의 변수 값을 가지고 있기 때문에
동시성 문제를 해결할 수 있습니다.
예를 들어, 트랜잭션에서 커넥션을 관리할 때 ThreadLocal을 사용하면 각 스레드가 고유한 커넥션을 관리하게 됩니다. 이렇게 하면, 같은 쓰레드에서 동작하는 모든 코드가 동일한 트랜잭션 커넥션을
사용할 수 있습니다. 반면, 다른 스레드는 이 커넥션에 접근할 수 없습니다.



** JdbcTemplate

1. JdbcTemplate 개요
JdbcTemplate은 스프링에서 제공하는 JDBC 유틸리티 클래스로, 데이터베이스와의 상호작용을 간편하게 처리할 수 있습니다.
JDBC 코드에서 반복적인 자원 관리(커넥션 열기/닫기 등)를 줄이고, SQL 실행과 결과 매핑에 집중할 수 있도록 도와줍니다.

2. 주요 기능

데이터 조회 (query 메서드): 여러 행의 결과를 처리할 때 사용합니다. RowMapper를 통해 각 행을 객체로 매핑할 수 있습니다.
String sql = "SELECT * FROM item WHERE price < ?";
List<Item> items = jdbcTemplate.query(sql, new Object[]{1000}, itemRowMapper());

단일 행 조회 (queryForObject 메서드): 결과가 단일 행일 때 사용합니다. 쿼리 결과가 여러 행이면 예외를 발생시킵니다.
String sql = "SELECT * FROM item WHERE id = ?";
Item item = jdbcTemplate.queryForObject(sql, new Object[]{id}, itemRowMapper());

데이터 수정 (update 메서드):INSERT, UPDATE, DELETE와 같은 데이터 수정 작업을 처리합니다.
String sql = "UPDATE item SET price = ? WHERE id = ?";
jdbcTemplate.update(sql, newPrice, itemId);

3. NamedParameterJdbcTemplate
이름 지정 파라미터(:parameterName)를 사용하여 SQL의 가독성을 높이는 기능을 제공합니다.
순서 기반 바인딩 대신, 이름 기반 바인딩을 사용하여 파라미터 설정이 더 명확합니다.
파라미터 소스로 Map, MapSqlParameterSource, BeanPropertySqlParameterSource 등을 사용하여 유연하게 파라미터를 전달할 수 있습니다.

4. SimpleJdbcInsert
INSERT 작업을 쉽게 처리할 수 있도록 도와주는 클래스입니다.
테이블 이름과 컬럼 이름만 설정하면, 자동으로 INSERT SQL을 생성하고 실행할 수 있습니다.
자동 생성된 키 값을 반환하는 기능도 제공하여, INSERT 작업 후에 자동 증가 ID를 쉽게 가져올 수 있습니다.

5. RowMapper의 활용
쿼리 결과를 객체로 매핑하는 역할을 하는 인터페이스입니다. BeanPropertyRowMapper를 사용하면 자동으로 결과를 객체의 필드에 매핑할 수 있습니다.
커스텀 매핑 로직이 필요한 경우 직접 RowMapper를 구현하여 매핑 로직을 정의할 수 있습니다.

6. 트랜잭션 관리
JdbcTemplate을 사용할 때도 스프링의 트랜잭션 관리 기능을 사용할 수 있습니다.
@Transactional 어노테이션을 통해 트랜잭션 범위를 설정하고, 트랜잭션 롤백 등의 작업을 손쉽게 처리할 수 있습니다.

7. 에러 처리와 예외 관리
스프링 JDBC는 SQL 예외를 스프링의 데이터 접근 예외로 변환하여, 더 직관적이고 일관된 예외 처리를 제공합니다.
예를 들어, **EmptyResultDataAccessException**은 조회 결과가 없을 때 발생하며, 빈 결과를 처리하는 로직을 쉽게 작성할 수 있습니다.

정리
JdbcTemplate은 JDBC 작업을 간소화하고, 반복적인 작업을 줄이는 데 유용합니다.
데이터 조회, 수정, 트랜잭션 관리, 예외 처리 등 다양한 기능을 제공하며, 스프링의 다른 기능들과 연동하기 쉽게 설계되어 있습니다.
이름 지정 파라미터와 SimpleJdbcInsert 등의 고급 기능을 통해 가독성과 유지보수성을 향상시킬 수 있습니다.




** 트랜잭션 동기화 매니저 (TransactionSynchronizationManager)
트랜잭션 동기화 매니저는 스프링 프레임워크에서 트랜잭션 범위 내에서의 자원(예: 데이터베이스 커넥션)을 관리하는 도구입니다.
TransactionSynchronizationManager는 내부적으로 ThreadLocal을 사용하여 현재 쓰레드와 연관된 트랜잭션 상태와 자원(커넥션 등)을 관리합니다.
트랜잭션이 시작될 때, TransactionSynchronizationManager는 현재 쓰레드에 트랜잭션 관련 정보를 등록하여 이후에 동일한 트랜잭션 내의 메서드 호출에서도 같은 자원을 사용할 수 있도록 합니다.
트랜잭션이 종료되면, TransactionSynchronizationManager가 쓰레드에 저장된 트랜잭션 정보를 정리합니다.

트랜잭션 동기화 매니저의 역할
트랜잭션 동기화 매니저는 트랜잭션 상태와 리소스를 관리하며, 트랜잭션의 롤백 전용 설정을 추적합니다.
TransactionStatus 객체에서 롤백 전용 상태가 설정되면, 동기화 매니저는 전체 트랜잭션을 롤백 전용으로 관리하고, 이후의 커밋 시도 시 롤백을 유도합니다.

TransactionStatus와 트랜잭션 동기화 매니저의 관계
TransactionStatus는 개별 트랜잭션의 상태를 추적하는 객체로, 트랜잭션의 롤백 전용 여부와 커밋 가능 여부를 관리합니다.
트랜잭션 동기화 매니저는 이러한 상태 변화를 인식하고, 전체 트랜잭션의 일관성을 유지하기 위해 리소스와 트랜잭션 상태를 조율합니다.




** TransactionManager vs DataSourceUtils

TransactionManager
트랜잭션의 시작과 종료(커밋/롤백)를 관리합니다.
트랜잭션 동기화 매니저를 통해 커넥션을 트랜잭션 범위 내에서 공유할 수 있도록 설정합니다.

DataSourceUtils
DataSourceUtils.getConnection()은 트랜잭션 동기화 매니저로부터 커넥션을 가져오고, 트랜잭션이 이미 시작된 경우 동일한 커넥션을 반환합니다.
DataSourceUtils.releaseConnection()은 커넥션을 트랜잭션 동기화 매니저에 반환합니다. 트랜잭션이 끝나기 전까지는 커넥션을 유지하고, 트랜잭션이 종료되면 자동으로 닫습니다.

결론적으로, transactionManager는 트랜잭션의 경계를 관리하는 데 사용되며, DataSourceUtils는 트랜잭션 범위 내에서 커넥션을 안전하게 사용하고 관리하는 데 도움이 됩니다.



**예외와 트랜잭션 커밋, 롤백
1. 예외 유형에 따른 기본 트랜잭션 처리 규칙:
스프링은 기본적으로 언체크 예외(런타임 예외) 발생 시 트랜잭션을 롤백하고, 체크 예외 발생 시에는 커밋합니다. 이는 언체크 예외가 복구 불가능한 시스템 오류로 간주되고, 체크 예외는 예측 가능하고 처리 가능한 비즈니스 예외로 간주되기 때문입니다.

2. 트랜잭션 롤백 규칙의 유연한 설정:
@Transactional 애노테이션의 rollbackFor와 noRollbackFor 속성을 사용하여, 특정 예외에도 롤백하거나 롤백을 방지할 수 있습니다. 이를 통해 비즈니스 로직에 맞는 트랜잭션 처리를 구현할 수 있습니다.

3. 비즈니스 예외와 롤백의 관계:
비즈니스 예외가 발생해도 반드시 트랜잭션을 롤백하지는 않습니다. 예외 상황이 데이터 일관성에 영향을 미치지 않거나, 로직 상 예외를 처리하고 계속 진행하는 것이 적절한 경우에는 커밋될 수 있습니다.
반면, 데이터 일관성을 유지해야 하는 상황에서는 비즈니스 예외라도 롤백이 필요할 수 있습니다. 이런 경우에는 rollbackFor 속성을 통해 롤백 대상을 설정해야 합니다.


** 내부 트랜잭션의 커밋 흐름
외부 트랜잭션 존재 시: 내부 트랜잭션의 커밋은 단순히 논리적 트랜잭션의 완료를 나타내며, 실제로 물리 커밋이 발생하지 않습니다. 외부 트랜잭션이 최종적으로 커밋을 요청할 때 물리적으로 커밋됩니다.
외부 트랜잭션이 없을 때: 내부 트랜잭션이 물리 트랜잭션 역할을 하며, 이때는 논리적 커밋이 곧 물리적 커밋이 됩니다.



** 외부 트랜잭션과 물리 트랜잭션

외부 트랜잭션
논리적인 트랜잭션의 역할을 강조하는 용어
외부 트랜잭션은 가장 바깥쪽에서 시작되는 트랜잭션을 말하며, 메서드 호출 체계에서 최상위 트랜잭션입니다.
예를 들어, MemberService.joinV1 메서드가 @Transactional로 선언되어 있다면, 이 메서드가 호출될 때 새로운 외부 트랜잭션이 시작됩니다.
이 외부 트랜잭션은 이후 호출되는 모든 내부 메서드들이 참여할 수 있는 트랜잭션 컨텍스트를 제공합니다.
외부 트랜잭션은 여러 내부 논리 트랜잭션들을 포함할 수 있으며, 모든 내부 트랜잭션이 완료된 후 외부 트랜잭션이 커밋되거나 롤백됩니다.

물리 트랜잭션
물리 트랜잭션은 데이터베이스와의 실제 트랜잭션을 의미하며, 데이터베이스 커넥션을 통해 트랜잭션이 시작되고, 커밋 또는 롤백되는 단위입니다.
물리 트랜잭션은 외부 트랜잭션에 의해 시작됩니다. 즉, 외부 트랜잭션이 시작될 때 물리 트랜잭션도 함께 시작됩니다.
모든 내부 논리 트랜잭션이 동일한 물리 트랜잭션을 공유하며, 물리 트랜잭션은 외부 트랜잭션이 종료될 때 커밋 또는 롤백됩니다.
외부 트랜잭션과 물리 트랜잭션의 관계
외부 트랜잭션이 물리 트랜잭션을 관리하는 컨텍스트 역할을 합니다. 외부 트랜잭션은 시작 시 물리 트랜잭션을 열고, 종료 시 물리 트랜잭션을 커밋하거나 롤백합니다.
외부 트랜잭션과 물리 트랜잭션은 동일한 트랜잭션을 나타내지만, 외부 트랜잭션은 논리적인 개념으로, 애플리케이션의 트랜잭션 범위를 설명할 때 사용되고, 물리 트랜잭션은 실제 데이터베이스와의 트랜잭션을 설명할 때 사용됩니다.


** 물리 트랜잭션에서의 커밋 처리

논리 트랜잭션의 커밋 호출:
각 논리 트랜잭션(memberRepository.save, logRepository.save 등)은 내부적으로 커밋을 호출할 수 있습니다. 이 커밋은 논리적 커밋으로, 현재 논리 트랜잭션이 정상적으로 완료되었음을 의미하지만, 실제 데이터베이스에 커밋되는 것은 아닙니다.
논리 트랜잭션의 커밋이 성공적으로 완료되면, 트랜잭션 매니저는 해당 작업을 유지하면서 물리 트랜잭션이 끝나기를 기다립니다.

물리 트랜잭션의 커밋 시점:
물리 트랜잭션의 커밋은 외부 트랜잭션이 종료될 때 한 번에 수행됩니다.
외부 트랜잭션이 종료될 때 트랜잭션 매니저는 rollbackOnly 플래그를 확인하고, 플래그가 설정되지 않은 경우 물리 트랜잭션 전체를 커밋합니다.
이때, 물리 트랜잭션 내에서 이루어진 모든 변경 사항이 한 번에 데이터베이스에 반영됩니다.

예외 및 롤백 시나리오:
만약 rollbackOnly 플래그가 설정되어 있다면, 물리 트랜잭션 커밋 시점에 모든 변경 사항이 롤백됩니다.
rollbackOnly 플래그는 물리 트랜잭션 내에서 발생한 예외에 의해 설정되며, 그로 인해 전체 물리 트랜잭션의 커밋이 취소되고, 롤백이 수행됩니다.

외부 트랜잭션에서 내부로부터 전파된 예외를 catch해서 처리한 경우
정상 흐름으로 전환된 외부 트랜잭션은 커밋을 시도하지만, rollbackOnly 상태에 의해 롤백으로 처리


* 롤백은 일반적으로 호출된 메서드들의 역순으로 진행
메서드 호출 순서와 자원 관리:
트랜잭션 내에서 메서드가 호출될 때마다 자원이 할당되거나 상태가 변경될 수 있습니다. 롤백 시에는 이러한 자원과 상태를 안전하게 정리해야 하므로, 가장 최근에 사용된 자원부터 정리하는 것이 안전합니다.

예외 전파에 따른 스택 구조:
트랜잭션의 예외 처리 과정은 스택 구조를 따릅니다. 따라서 예외가 발생하면 호출된 메서드들이 스택에서 차례로 제거되면서 롤백이 진행됩니다.



** Hibernate 

JPA 구현체. JPA는 자바의 표준 ORM (Object Relational Mapping)

1. 엔티티 매니저 팩토리(EntityManagerFactory)

1) 생성 시점
애플리케이션이 시작될 때 한 번만 생성되며, 애플리케이션 전역에서 공유된다.
설정 파일(persistence.xml 또는 스프링의 application.properties)에 정의된 설정 정보를 기반으로 초기화된다.

2) 역할
EntityManagerFactory는 엔티티 매니저(EntityManager)를 생성하는 팩토리 역할을 한다.
애플리케이션에서 데이터베이스와 상호작용하기 위한 핵심 구성 요소다.

3) 참조하는 주요 정보
데이터베이스 연결 정보: JDBC URL, 사용자명, 비밀번호.
JPA 구현체 옵션: Hibernate Dialect, 캐시 설정 등.
관리할 엔티티 목록: 애플리케이션에서 JPA로 관리하는 엔티티 클래스.
트랜잭션 관리 방식: JTA(분산 트랜잭션) 또는 RESOURCE_LOCAL(단일 트랜잭션).


2. 엔티티 매니저(EntityManager)

1) 생성 시점
EntityManagerFactory를 통해 생성되며, 일반적으로 트랜잭션 범위 내에서만 유효하다.
트랜잭션이 시작될 때 EntityManager가 활성화된다.

2) 역할
데이터베이스와의 상호작용을 담당하며, 엔티티를 조회, 저장, 수정, 삭제하는 작업을 수행한다.
영속성 컨텍스트를 관리하는 주체로, 영속성 컨텍스트와의 모든 작업은 EntityManager를 통해 이루어진다.

3) 프록시로 관리
스프링 환경에서는 EntityManager를 프록시 객체로 관리하여, 트랜잭션이 시작될 때만 실제 객체를 생성한다.
이를 통해 개발자가 직접 EntityManager를 생성하거나 종료할 필요가 없다.

4) 주입 방식
@PersistenceContext: JPA 표준 애노테이션으로, EntityManager를 주입받는 데 사용된다.
JPA 표준을 준수하며, 트랜잭션 범위, 동기화 방식, 영속성 컨텍스트 타입 등을 세부적으로 설정할 수 있다.
추가 설정이 가능하기 때문에 스프링에서도 기본적으로 권장된다.
@Autowired 스프링 DI 애노테이션으로도 주입받을 수 있으나, JPA 표준 기능을 사용할 수 없어 간단한 경우에만 사용된다.


3. 영속성 컨텍스트(Persistence Context)

1) 정의
영속성 컨텍스트는 JPA가 관리하는 엔티티 객체의 상태를 추적하고 데이터베이스와 동기화하는 메모리 공간이다.
엔티티의 1차 캐시 역할을 하며, 데이터의 일관성과 효율적인 조회/변경을 보장한다.

2) 생성 및 관리
생성: EntityManager가 활성화될 때 영속성 컨텍스트가 생성된다.
관리 주체: EntityManager가 영속성 컨텍스트를 관리하며, 엔티티의 상태를 추적한다.
소멸: 트랜잭션 종료와 함께 영속성 컨텍스트도 종료된다.

3) 주요 기능

1차 캐시:
엔티티를 메모리에 캐싱하여 동일한 엔티티에 대한 반복 조회를 방지.
동일 트랜잭션 내에서는 같은 식별자를 가진 엔티티는 항상 동일한 인스턴스를 반환.

변경 감지 (Dirty Checking):
영속성 컨텍스트에 저장된 엔티티의 상태를 추적하여 변경 사항을 자동으로 감지.
트랜잭션 커밋 시 변경 사항을 데이터베이스에 반영.

쓰기 지연:
트랜잭션 종료 시점에 모든 SQL 명령을 한꺼번에 데이터베이스에 전송.
이는 성능 최적화를 위한 메커니즘으로, 엔티티의 변경 사항이 즉시 반영되지 않는다.

엔티티 상태 관리:
영속 상태(Persistent): 영속성 컨텍스트에 관리되는 엔티티.
준영속 상태(Detached): 영속성 컨텍스트에서 분리된 엔티티.
비영속 상태(Transient): 아직 영속성 컨텍스트에 저장되지 않은 엔티티.


4. 트랜잭션과 영속성 컨텍스트의 관계

1) 트랜잭션 시작
트랜잭션이 시작되면 EntityManager가 활성화되며, 영속성 컨텍스트가 생성된다.

2) 트랜잭션 범위에서의 동작
엔티티는 트랜잭션 범위 내에서 영속 상태로 관리되며, 변경 감지와 쓰기 지연 메커니즘이 작동한다.
동일 트랜잭션 내에서 조회된 엔티티는 항상 영속성 컨텍스트에서 관리되므로, 데이터베이스와 불필요한 추가 상호작용을 방지한다.

3) 트랜잭션 종료
트랜잭션이 커밋되면 영속성 컨텍스트의 변경 사항이 데이터베이스에 반영된다.
트랜잭션이 롤백되면 변경 사항은 무효화되며, 영속성 컨텍스트도 종료된다.


5. 개발자가 사용하는 주요 구성 요소
개발자는 보통 영속성 컨텍스트를 직접적으로 다루지 않으며, 아래와 같은 방법으로 간접적으로 사용한다:

1) EntityManager 메서드
persist(entity): 엔티티를 영속성 컨텍스트에 저장.
find(Entity.class, id): 영속성 컨텍스트 또는 데이터베이스에서 엔티티를 조회.
remove(entity): 엔티티를 영속성 컨텍스트 및 데이터베이스에서 삭제.
merge(entity): 준영속 상태의 엔티티를 다시 영속성 컨텍스트에 병합.

2) 트랜잭션
개발자는 @Transactional 애노테이션을 사용하여 트랜잭션을 선언.
트랜잭션의 범위에 따라 EntityManager와 영속성 컨텍스트가 자동으로 관리된다.


6. 전체 흐름 정리

설정 정보 로드:
persistence.xml 또는 application.properties에서 JPA 관련 설정을 로드하여 EntityManagerFactory를 초기화.

EntityManagerFactory 생성:
애플리케이션 시작 시 전역적으로 하나만 생성되며, 엔티티 매니저를 생성하는 팩토리 역할을 수행.

EntityManager 생성:
트랜잭션 시작 시 EntityManagerFactory에서 EntityManager가 생성되며, 영속성 컨텍스트가 초기화됨.

영속성 컨텍스트 초기화:
EntityManager가 활성화되면서 영속성 컨텍스트가 생성되고, 엔티티 상태를 관리.

트랜잭션 종료 시:
영속성 컨텍스트는 데이터베이스와 동기화한 후 종료된다.




** JPA Auditing

1. JPA Auditing이란?
엔티티의 생성 시간, 수정 시간, 작성자, 수정자를 자동으로 기록해주는 기능.
반복적인 시간 관리 코드를 줄이고 일관성을 유지함.


2. 애노테이션 사용법

(1) 애플리케이션 클래스

JPA Auditing 기능 활성화:

@SpringBootApplication
@EnableJpaAuditing
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}


(2) 엔티티 클래스

Auditing 기능 활성화:

@EntityListeners(AuditingEntityListener.class)
@Entity
public class Article {


    @CreatedDate // 생성 시간 자동 기록
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate // 수정 시간 자동 기록
    private LocalDateTime updatedAt;


Spring Security 등을 통해 작성자/수정자를 기록

@CreatedBy
private String createdBy;

@LastModifiedBy
private String modifiedBy;





** 객체와 데이터베이스 검증의 역할과 상호 보완성

1. 객체와 데이터베이스의 역할 구분
객체는 애플리케이션 내에서 비즈니스 로직을 수행하고 데이터를 관리하며, 상태를 항상 유효하게 유지해야 한다.
데이터베이스는 데이터의 저장소로서 무결성을 보장하며, 저장된 데이터의 신뢰성을 유지하는 데 중점을 둔다.
이 둘은 서로 다른 책임을 가지며, 객체와 데이터베이스 각각의 역할에 맞는 검증이 필요하다.


2. 검증의 두 가지 방식

1) 객체 검증
객체 검증은 데이터를 데이터베이스에 저장하기 전에, 애플리케이션 내부에서 상태를 미리 확인하고 관리하는 것을 목표로 한다.

목적: 객체의 상태를 변경하거나 생성할 때, 잘못된 데이터를 사전에 방지한다.
특징: 데이터베이스 접근 전에 수행되므로 성능 저하를 최소화하며, 비즈니스 로직과 유효성 검증을 결합할 수 있다.
예시: Member 클래스의 changeName() 메서드 내부에서 null 값이나 빈 문자열이 들어오지 않도록 검증하는 로직.

2) 데이터베이스 검증
데이터베이스 검증은 데이터 저장소 수준에서 데이터의 최소한의 무결성을 보장한다.

목적: 잘못된 데이터가 저장되는 것을 방지하며, 객체 검증이 누락되었거나 외부에서 잘못된 데이터가 들어온 경우를 대비한다.
특징: 저장 시점에 실행되며, 제약 조건(NOT NULL, UNIQUE 등)을 통해 데이터의 신뢰성을 유지한다.
예시: Member 클래스의 필드에 @Column(nullable = false)로 NOT NULL 조건을 부여하여 null 값이 저장되지 않도록 설정.


3. 객체 검증과 데이터베이스 검증의 상호 보완
객체 검증과 데이터베이스 검증은 서로 다른 수준에서 동작하며, 상호 보완적인 역할을 한다.

객체 검증은 선제적 방어 역할을 한다.
데이터가 잘못된 상태로 데이터베이스에 전달되기 전에 검증을 통해 애플리케이션에서 문제를 사전에 해결한다.

데이터베이스 검증은 최종 방어선 역할을 한다.
객체 검증이 누락되었거나, 외부에서 잘못된 데이터가 데이터베이스에 직접 접근하는 경우에도 데이터 무결성을 유지한다.

책임 분리를 통해 역할을 명확히 한다.
객체는 비즈니스 로직과 상태 관리를, 데이터베이스는 저장소로서의 역할과 기본적인 데이터 제약을 맡아 서로 독립적으로 관리된다.


4. 실무에서의 활용

객체 내부 검증
객체의 상태를 변경하거나 생성할 때, 상태 변경 메서드 내부에서 비즈니스 규칙에 따라 검증을 수행한다.
예를 들어, 이름 변경 메서드에서 null 값이나 빈 문자열을 방지하는 로직을 포함한다.

데이터베이스 제약 설정
데이터베이스에 기본적인 제약 조건을 설정하여, 데이터의 무결성을 유지한다.
예를 들어, nullable = false를 사용해 null 값이 저장되지 않도록 설정한다.

검증 책임의 분리와 결합
객체 검증은 비즈니스 규칙을 충족하며 애플리케이션 내부의 로직에 집중하고, 데이터베이스 검증은 저장소로서 데이터의 최소 무결성을 보장하는 역할을 맡는다.


5. 결론
객체와 데이터베이스는 각각의 역할에 맞는 검증을 수행하며, 서로를 보완적으로 활용한다.
객체 검증은 데이터가 애플리케이션 내부에서 유효한 상태를 유지하도록 하고, 데이터베이스 검증은 저장소로 전달된 데이터의 최소 무결성을 보장한다.

이 두 가지 검증 방식을 함께 사용하면 데이터의 신뢰성과 애플리케이션의 안정성을 모두 확보할 수 있다. changeName()과 @Column(nullable = false)는 이를 실현하는 대표적인 예시로, 객체와 데이터베이스가 각각의 책임에 맞게 데이터를 관리하는 방식을 보여준다.




** JPA에서 주키 필드를 Long으로 선언한 이유?

JPA의 엔티티 생명주기에서 null 상태를 다루기 위함.
null 상태를 통해 신규 엔티티 여부를 명확히 판단.
long(기본형)은 초기값이 0이므로, JPA와 DB의 동작에 혼란을 줄 가능성이 있음.