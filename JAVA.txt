** 17 이전 vs 이후

문자열 여러줄 작성
이전 : \n 입력으로 줄바꿈 명시.
이후 : 큰따옴표 두개 겹쳐 쓰고 줄바꾸면 자동으로 적용.
"" ㅁㄴㅇㄹ
ㅁㄴㅇㄹ
ㅁㄴㅇㄹ"" 

formatted()메서드 : 파싱 편의성 증대.



** JVM에서 사용하는 -D 옵션
대문자 D는 "Define"의 약자로, JVM에 시스템 속성을 정의하거나 설정한다는 의미입니다.
이 옵션은 -Dproperty=value 형식으로 특정 시스템 속성을 지정할 때 사용됩니다.

-D 옵션의 역할
시스템 속성 정의: -D 옵션은 JVM이 실행될 때 특정 시스템 속성(property)을 정의하거나 값을 설정하는 데 사용됩니다.
JVM 내에서 접근 가능: -D로 설정한 속성은 자바 애플리케이션 내부에서 System.getProperty("property")로 접근할 수 있습니다.
예를 들어, -Dfile.encoding=UTF-8은 JVM에 file.encoding이라는 속성을 정의하고, 그 값을 UTF-8로 설정하라는 의미입니다. 이 속성은 이후 자바 애플리케이션이 실행되는 동안 JVM 환경에 포함되어 애플리케이션에서 참조하거나 사용할 수 있게 됩니다.

따라서, -D는 JVM에 필요한 설정 값을 정의할 때 사용하는 표준 형식이며, Define의 의미로 해석할 수 있습니다.


** 리터럴 
코드에서 개발자가 직접 적은 100, 10.5, true, 'A', "Hello Java"와 같은 고정된 값을 프로그래밍 용어로 리터럴(literal)이라 한다.
변수의 값은 변할 수 있지만 리터럴은 개발자가 직접 입력한 고정된 값이다. 따라서 리터럴 자체는 변하지 않는다.

int a = 100; //정수 리터럴
double b = 10.5; //실수 리터럴
boolean c = true; //불리언 리터럴
char d = 'A'; //문자 리터럴
String e = "Hello Java"; //문자열 리터럴



** 리터럴 뒤에 'L' 붙이는 이유 :
long l = 12312321; // 리터럴이 int 범위 안 -> ok
long ll = 1231231321312; // 리터럴이 int 범위 밖 -> 예외 발생.
long lll = 1232131231412213L; // 리터럴에 L 접두어 붙여 long 타입임을 명시 -> ok
        
java는 정수 리터럴을 int로 간주함.
또한 리터럴의 타입이 먼저 결정된다. 
변수 선언과 초기화를 동시에 하더라도, 리터럴의 타입이 먼저 결정됨.
따라서 변수 타입을 L으로 해도 리터럴은 int로 인식됨.
int값의 범위를 넘어가는 숫자 리털럴은 L을 붙여 int가 아닌 Long이라고 명시해줘야함. 


** float 리터럴에서 F 또는 f를 사용해야 하는 이유
모두 부동소수점(floating-point) 타입이지만, 기본적으로 Java는 부동소수점 리터럴을 double 타입으로 간주함.

double은 Java에서 기본 부동소수점 타입으로, 64비트(8바이트)
float는 부동소수점 값의 메모리 사용을 줄이기 위해 제공된 타입으로, 32비트(4바이트)

Java는 기본적으로 부동소수점 리터럴을 double로 간주
따라서, 3.14와 같은 리터럴은 double로 처리됨.

만약 float 변수에 값을 할당할 때, 리터럴을 그대로 사용하면 컴파일러가 double로 해석하고, float에 double을 대입하는 형식으로 인식.
따라서 float 타입임을 명시하기 위해 리터럴 뒤에 **F 또는 f**를 붙여야.

float myFloat = 3.14F; // 3.14를 float 리터럴로 지정
double myDouble = 3.14; // 기본적으로 double로 간주됨



** parameter
메서드가 정의될 때 선언된 받을 변수(Xxx xxx). 매개변수.


** argument
메서드를 호출할 때 실제로 전달하는 값. 인자. args = arguments 


* final 필드의 초기화
final 필드는 생성과 동시에 초기화하거나(클래스 로드 시점), 생성자를 사용해서 초기화할 수 있음(객체 생성 시점)
final 필드는 불변하므로 setter를 사용해 초기화할 수 없다.
세터 메서드를 통해 필드를 초기화하거나 변경하는 방식은 객체 생성 후에 이루어지며, 선택적 의존성 주입이나 설정 값을 변경할 때 사용.


** 익명 클래스로 Runnable 인터페이스의 run() 메서드 구현
    Runnable userX = new Runnable() {
        @Override
        public void run() {
            fieldService.logic("userZ");
        }
    };

* 람다식으로 익명 클래스를 더 간결하게 작성
    조건 : 익명 클래스가 단일 메서드를 가진 함수형 인터페이스를 구현할 것 (두개 이상 있으면 람다식에서는 메서드 이름 지워버리니까 어떤 메서드인지 알 수 없다)
    익명 클래스에서 Runnable의 run() 메서드를 오버라이드하는 부분을 제거하고, 람다 표현식의 형태로 구현 내용만 남김.
    Runnable의 run() 메서드는 매개변수를 받지 않으므로 빈 괄호 ()로 표시.

    Runnable userZ = () -> fieldService.logic("userZ");



** Java 웹 애플리케이션의 메모리 구조와 변수/리터럴/객체의 범위 (스프링 빈 자동 주입 포함)

Java 웹 애플리케이션에서는 메모리 구조와 변수, 리터럴, 객체의 범위가 서로 결합되어 동작합니다. 이를 이해하기 위해 Java 메모리 구조, 컴파일과 런타임에서의 변수 초기화와 객체 저장 방식, 스프링 빈 자동 주입 개념을 포함해 정리하겠습니다.

1. Java 메모리 구조
Java 애플리케이션은 메모리를 크게 스택(Stack), 힙(Heap), 메서드 영역(Method Area)으로 나누어 관리합니다.

- 스택(Stack): 메서드 호출 시 생성되는 로컬 변수와 메서드 실행 순서를 관리하는 공간입니다. 메서드가 끝나면 해당 스택 프레임이 제거되며, 로컬 변수도 함께 사라집니다.

- 힙(Heap): new 키워드로 생성된 객체와 배열이 저장되는 공간입니다. 객체의 수명은 참조 상태에 따라 결정되며, 참조되지 않는 객체는 가비지 컬렉터에 의해 메모리에서 자동 해제됩니다.

- 메서드 영역(Method Area): 클래스 로딩 시 로드된 클래스 메타데이터, static 변수, 상수, 메서드 코드 등이 저장되는 공간입니다. 클래스가 로드되면 프로그램 종료 시까지 유지되는 영역입니다.

2. 컴파일 시점과 런타임 시점에서의 변수 초기화와 객체 저장
변수와 객체의 저장 위치는 컴파일 시점과 런타임 시점에서 다르게 결정됩니다.

컴파일 시점 (Compile Time)
- 변수의 초기화 정보만 기록됩니다. 예를 들어, int a = 5;라는 선언이 있을 경우, 컴파일 시에는 a가 초기화될 값(5)이 기록될 뿐 실제 값이 메모리에 저장되지는 않습니다.
- 이 값은 바이트코드에 포함되어 런타임에 로드됩니다.

런타임 시점 (Runtime)
- 런타임 시점에 메모리가 실제로 할당되고, 컴파일 시 기록된 초기화 정보에 따라 변수가 메모리에서 초기화됩니다.
- 예를 들어, 로컬 변수 int a = 5;는 메서드가 호출될 때 스택에 위치하고, 런타임에 5라는 값이 스택 메모리에 저장됩니다.

3. 변수와 리터럴, 객체의 차이와 저장 위치

변수 (Variable)
변수는 데이터를 저장하기 위한 이름이 있는 메모리 공간으로, 선언 위치에 따라 메모리 영역과 수명이 다릅니다.

로컬 변수 (Local Variable): 메서드나 블록 내부에 선언된 변수로, 스택에 저장됩니다.
수명: 메서드 호출 동안 유지되고, 메서드가 끝나면 제거됩니다.

인스턴스 변수 (Instance Variable): 객체의 필드로 선언된 변수이며, 객체가 생성될 때 힙에 저장됩니다.
수명: 객체가 참조되는 동안 유지되며, 객체가 더 이상 참조되지 않으면 가비지 컬렉션 대상이 됩니다.

클래스 변수 (Class Variable / Static Variable): static 키워드로 선언된 변수로, 메서드 영역에 저장되며, 모든 인스턴스가 공유합니다.
수명: 클래스가 로드된 후 프로그램 종료 시까지 유지됩니다.

리터럴 (Literal)
리터럴은 값 자체를 의미하는 상수로, 변수 초기화 시 사용됩니다.

정수, 실수, 문자, 논리 리터럴은 컴파일 시 초기화 값으로 기록되며, 런타임에 해당 값이 변수에 할당됩니다.

문자열 리터럴은 Java의 String Pool에 저장되어 중복 생성을 피하고 재사용됩니다.

객체 (Object)
객체는 new 키워드로 생성되는 실제 데이터 구조로, 힙(Heap)에 저장됩니다.

수명: 참조가 유지되는 동안 힙에 존재하며, 모든 참조가 끊기면 가비지 컬렉션 대상이 됩니다.

4. 스프링 프로젝트에서의 메모리 구조 (빈과 의존성 주입 포함)
스프링 프로젝트에서 사용되는 빈 객체와 의존성 주입된 객체는 기본적으로 힙 메모리에 존재합니다. 스프링 컨테이너가 이들 객체의 생명주기를 관리하며, 이로 인해 메모리 위치와 수명이 결정됩니다.

예시: 스프링 빈과 의존성 주입
설정: @Service 애노테이션이 붙은 서비스 클래스가 있으며, @Autowired로 의존성을 주입받습니다.

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service // 서비스 범위 (싱글톤 스코프)
public class MyService {
    private final MyRepository repository;

    @Autowired // 필드에 주입된 의존성
    public MyService(MyRepository repository) {
        this.repository = repository;
    }
}

메모리 구조 분석
1. MyService 클래스:
    - @Service 애노테이션이 붙은 스프링 빈으로 등록됩니다.
    - 싱글톤 빈으로 관리되며 힙 메모리에 저장됩니다. 애플리케이션 종료 전까지 스프링 컨테이너가 이 객체를 관리하며, 참조가 유지됩니다.

2. 주입된 의존성 MyRepository 객체:
    - @Autowired로 주입된 또 다른 스프링 빈입니다.
    - 스프링이 생성한 싱글톤 빈으로, MyService와 마찬가지로 힙 메모리에 저장됩니다.
    - 스프링 컨테이너가 이 객체의 생명주기를 관리하며, 필요 시 여러 빈에 동일한 객체를 주입해 재사용할 수 있습니다.

요약
Java 메모리 구조는 스택, 힙, 메서드 영역으로 나뉘며, 변수의 종류에 따라 저장 위치와 수명이 달라집니다.
컴파일 시점과 런타임 시점에서의 변수 초기화:
    컴파일 시점: 변수의 초기화 정보만 기록됩니다.
    런타임 시점: 메모리에 실제 값이 할당됩니다.
스프링 빈의 자동 주입:
    @Service, @Autowired 등으로 스프링 컨테이너가 관리하는 객체들은 싱글톤 빈으로 힙 메모리에 존재하며, 컨테이너가 애플리케이션 종료까지 생명주기를 관리합니다.



** 증감 연산자

 전위   vs  후위
 ++a;       a++;

대입하지 않고 단독으로 사용할 때는 둘에 기능 차이 없음.
(반환하는 값에서 차이가 있는건데 반환을 안하니까)

int a = 1;
int b = 0;

b = a++;
a값을 반환한 뒤 a값을 증가시킨다.
b = 1;

b = ++a;
a값을 증가시킨 뒤 a값을 반환한다.
b = 2;



** 문자열 비교에 == 대신 .equals()를 사용하는 이유

같은 문자열을 참조하는 문자열 변수를 비교할 때 == 를 사용하면 내용이 같은 문자열이라도 false 나올 수 있기 때문이다.

"asdf";
이렇게 하면 일단 heap 영역의 String Pool에 문자열 객체가 저장되고, 이 메모리의 위치를 나타내는 주소가 생성된다.

str = "asdf";
이렇게 하면, 위의 과정이 일어나고 str에는 그 주소가 저장된다. 따라서 str은 문자열 객체의 내용이 아니라 주소를 가지는 참조변수가 된다.

"asdf" == "asdf";
이렇게 문자열 리터럴끼리 ==로 비교한다면, 내용이 같은 문자열이라면 String pool에 저장된 동일한 객체의 메모리 주소를 사용하기 때문에 true를 반환한다.

String s1 = "hello"; 
String s2 = "hello"; 
"hello"는 String Pool에 저장되고, s1은 이를 참조
같은 "hello"를 참조 (String Pool 내 동일 객체)
문자열 변수를 ==로 비교하면 참조 변수가 가진 주소("Hello" String 객체의 주소)가 같기 때문에 true를 반환한다.

같은 내용의 문자열을 ==로 비교했는데 false가 나오는 경우

String 객체를
String s1 = new String("abc");
이렇게 선언하고 s1 참조변수를 초기화 했을 경우, "abc" String 객체는 스트링 풀이 아니라 heap 영역에 생성된다.
new 연산자는 매번 새로운 객체 생성을 보장하기 위해 힙에 새로운 메모리 주소를 할당함.
이는 String Pool과는 전혀 별도의 공간으로, 같은 내용의 문자열이라도 생성할 때마다 매번 heap 영역에서 다른 메모리 주소를 가진다.
즉, new로 생성한 문자열은 기본적으로 String Pool을 전혀 사용하지 않는다.

따라서 
s1 == "abc";
혹은
String s2 = new String("abc");
s2 == s1;
모두 false가 된다.

이렇듯 참조변수에 대해 비교연산자를 사용할 경우, 참조변수가 가지고 있는 대상 객체의 주소를 비교하기 때문에 객체가 담고 있는 내용과 무관한 결과를 얻게된다.
문자열의 내용을 비교하기 위해서는 .equals 메서드를 사용해야 한다.


** 복합 대입 연산자

int a = 1;

a += 1;  ->  a = a + 1;  ->  2
-=
*=
/=
%=



** 조건문

정상 흐름 먼저? 예외 먼저?

현대의 대부분의 애플리케이션에서 사람이 코드를 읽고 이해하는 시간이 코드가 실행되는 시간보다 훨씬 더 중요합니다. 다음과 같은 이유로 가독성과 유지보수성이 우선되어야 합니다:

가독성
코드의 목적이 명확해야 버그를 줄이고 유지보수를 쉽게 할 수 있습니다.
예외적인 상황보다 정상적인 흐름이 먼저 드러나면, 코드가 의도하는 동작을 한눈에 파악하기 쉽습니다.

유지보수성
코드 수정이나 확장 시, 읽기 좋은 코드가 수정하기에도 좋습니다.
정상 흐름이 명확히 드러나야 예외적인 상황을 추가하거나 변경하기도 쉽습니다.

단, 특정 조건에서 예외를 빠르게 종료하는 경우에는 예외를 먼저 처리하는 것이 더 효과적입니다.




** if

* if-else if 구조의 동작 방식
if-else if 구조에서는 첫 번째로 참인 조건이 발견되면 이후 조건은 평가되지 않고 바로 해당 블록이 실행됩니다.
즉, 하나의 조건이 참으로 확인되면 나머지 조건들은 무시됩니다.

int age = 20;

if (age < 18) {
    System.out.println("미성년자입니다.");
} else if (age < 30) {
    System.out.println("청년입니다.");
} else {
    System.out.println("성인입니다.");
}

청년입니다.


* 독립적인 if 문을 연달아 사용하는 경우
각 if 문이 독립적으로 평가되므로, 모든 if 문이 실행될 가능성이 있습니다.
앞의 조건이 참이든 거짓이든 상관없이 모든 if 조건을 차례로 확인하게 됩니다.

int age = 20;

if (age < 18) {
    System.out.println("미성년자입니다.");
}

if (age < 30) {
    System.out.println("청년입니다.");
}

if (age >= 18) {
    System.out.println("성인입니다.");
}

청년입니다.
성인입니다.



** for문

for (초기화; 조건식; 증감식) {
    // 반복 실행할 코드
}

초기화: 반복문 실행 전에 한 번 실행. 변수 선언과 초기화가 이루어질 수 있음. 
	  초기화한 변수는 스코프 범위가 for문으로 제한됨.
조건식: 반복 여부를 결정. boolean 타입으로 평가될 수 있는 식이어야 함.
증감식: 반복문의 각 반복이 끝날 때마다 실행.

꼭 변수가 int 아니어도 된다. 조건식이 true/false로 평가도리 수 있기만 하면 된다.
즉, 초기화와 증감식은 제한이 없다.
조건식을 생략하면 무한루프 while(true) 가 된다.

        // int 타입 조건식
        for (int i = 0; i < 5; i++) {
            System.out.println(i);
        }

        // double 타입 조건식
        for (double d = 0.0; d < 1.0; d += 0.2) {
            System.out.println(d);
        }

        // boolean 조건
        boolean keepGoing = true;
        for (int j = 0; keepGoing; j++) {
            System.out.println(j);
            if (j == 3) keepGoing = false; // 조건 종료
        }



** 형변환
int long double
작은 범위에서 큰 범위로는 대입할 수 있다.
이것을 묵시적 형변환 또는 자동 형변환이라 한다.
큰 범위에서 작은 범위의 대입은 다음과 같은 문제가 발생할 수 있다. 이때는 명시적 형변환을 사용해야 한다.
소수점 버림 
오버플로우
연산과 형변환
같은 타입은 같은 결과를 낸다.
서로 다른 타입의 계산은 큰 범위로 자동 형변환이 일어난다.



** 형변환과 별도 처리 필요성

1. 형변환은 컴파일 타임에 결정됨
형변환은 값이 아니라 타입 간 관계에 따라 컴파일 타임에 이루어짐.
값은 런타임에 전달되지만 형변환 가능 여부는 컴파일러가 미리 판단.
형변환은 타입 간 규칙에 따라 작동하지만, 값에 따라 문제를 일으킬 수 있음.
안전한 프로그램을 작성하려면 형변환 전에 범위 확인, 정밀도 손실 관리, 예외 처리를 반드시 추가해야 함.


2. 런타임 값에 따라 문제 발생 가능
컴파일 타임에는 형변환 가능 여부만 판단하고, 실제 값의 범위는 검증하지 않는다.
런타임에 주어진 값이 변환 대상 타입의 표현 범위를 초과하면 오버플로우가 발생한다.
자동 형변환에서는 범위 초과 문제가 없지만, 정밀도가 높은 타입에서 낮은 타입으로 변환될 때 데이터 손실이 발생할 수 있다.

2-1 자동 형변환
자동 형변환은 데이터 손실 위험이 없다고 판단될 때 컴파일러가 자동으로 처리한다.
하지만, 데이터 타입이 변경되면서 정밀도 손실이 발생할 수 있다.

예: long에서 double로 변환
long value = Long.MAX_VALUE; // 9223372036854775807
double result = value; // 자동 형변환
System.out.println(result); // 9.223372036854776E18 (정밀도 손실 발생)

위 코드에서 double은 정밀도가 약 15~17자리이므로, long의 정밀도가 일부 손실된다.

2-2 명시적 형변환
명시적 형변환은 데이터 손실 가능성을 개발자가 수동으로 허용하는 방식이다.
컴파일러는 명시적 형변환을 허용하지만, 값이 대상 타입의 범위를 초과할 경우 오버플로우가 발생할 수 있다.

예: long에서 int로 변환
long value = 2147483648L; // int 범위를 초과하는 값
int result = (int) value; // 명시적 형변환
System.out.println(result); // -2147483648 (오버플로우 발생)

이 코드에서 2147483648은 int의 최대값 2147483647를 초과하므로, 상위 비트가 잘려나가 왜곡된 값 -2147483648이 저장된다.


3. 형변환 문제 방지를 위한 처리 방법
이를 방지하기 위해 런타임 값에 대해 추가적인 처리(예: 범위 체크, 예외 처리)가 필요하다.

범위 체크: 변환 전 값이 대상 타입의 범위를 초과하지 않는지 확인
Math 클래스 활용: Math.addExact 등으로 오버플로우 발생 시 예외 처리.
BigInteger/BigDecimal 사용: 큰 수와 정밀도를 처리할 때 활용.
타입 확장: 더 큰 데이터 타입으로 변환하여 데이터 손실 방지.
로그 및 예외 처리: 변환 후 값 왜곡이 발생하면 로그로 기록하거나 예외 발생.



** InputStream과 Stream API는 별개의 개념이며, 서로 다른 목적을 가짐.
InputStream은 외부 데이터 소스(I/O)와의 통신을 다루는 저수준 스트림.
Stream API는 컬렉션과 배열의 데이터 처리를 위한 고수준 스트림.



** Scanner
java.util.Scanner
Scanner 객체는 입력 데이터를 보관하지 않고, 입력 소스에서 데이터를 읽어오고 처리하는 역할만 수행합니다.
데이터가 필요하면 사용자가 직접 읽은 데이터를 **컬렉션(List, Array 등)**에 저장하여 관리해야 합니다.

nextLine()
한 줄 단위로 문자열을 읽음.
줄바꿈(Enter)을 기준으로 입력을 종료.

next()
공백(스페이스, 탭, 줄바꿈 등)을 기준으로 단어를 읽음.
한 번에 한 "토큰"을 반환.

데이터 타입별 읽기
next()와 마찬가지로 공백을 기준으로 단어를 읽음.
타입이 맞지 않으면 InputMismatchException 발생.
nextInt(): 정수를 읽음.
nextDouble(): 실수를 읽음.
nextBoolean(): 논리값(true/false)을 읽음.
nextLong(): 긴 정수를 읽음.

hasNextLine()
다음 줄이 존재하는지 확인.
입력이 더 이상 없으면 false 반환.



** 배열
배열은 메모리에서 연속된 공간에 저장되며, 인덱스를 사용해 각 요소를 구분.

배열(Array):
메모리 상의 특정 연속적인 공간(아파트)을 의미.
배열의 참조(주소)는 아파트 자체의 주소를 나타냄.

배열 선언 시 타입 지정:
배열이 데이터의 일관성을 유지하기 위한 설계.
배열은 메모리에서 연속된 공간에 동일한 크기의 데이터만 저장함.
배열은 한 가지 데이터 타입의 요소만 저장할 수 있으므로, 선언 시 타입을 지정하면 다른 타입의 데이터는 들어갈 수 없음.
여성 / 공무원 / 군인 아파트.

슬롯(Slot) 또는 셀(Cell):
배열 내부의 각각의 공간(아파트의 빈 방)으로, 데이터를 저장할 수 있음.
방의 위치는 배열의 **인덱스(Index)**로 구분.

인덱스(Index):
아파트의 호수로, 방의 고유 번호.
0번 호수부터 시작하며, 배열 크기만큼 호수가 붙음.

요소(Element):
배열에 저장되는 실제 데이터(입주민).
입주민은 **주소(참조)**와 **호수(인덱스)**를 통해 해당 방에 입주하거나 방문 가능.

배열 변수는 이 연속된 메모리를 참조하고, 루프를 통해 요소를 동적으로 다룰 수 있음.

일반 변수는 각각 독립적인 이름으로 메모리에 저장되며, 배열처럼 인덱스를 사용해 접근하는 개념이 없음.
따라서 각 변수에 직접 접근해야 함.


** 향상된 for문은 인덱스를 제공하지 않고, 배열이나 컬렉션의 각 요소 값을 순차적으로 가져옴.
따라서, 인덱스가 필요한 작업(예: 배열의 특정 슬롯에 값을 채우는 작업)을 수행하려면 향상된 for문을 사용할 수 없고, 일반 for문을 사용해야.



** Static

1. Static의 기본 개념
Static은 객체 지향 설계의 유연함과 독립성에 더해, 공통적인 데이터와 동작을 효율적으로 관리하기 위해 도입된 키워드이다.
Static 멤버는 클래스 자체에 속하며, 객체와 독립적으로 동작한다.
Static 필드와 메서드는 객체를 생성하지 않고도 클래스 이름으로 직접 호출할 수 있다.
JVM의 메서드(Method Area)에 저장되며, 클래스 로드 시 초기화되고 프로그램 종료 시까지 유지된다.

2. Static 필드의 설계 의도
클래스 로드 시 한 번만 초기화.
Static 필드는 공통 상태를 관리하기 위해 설계되었다. 모든 객체가 동일하게 접근해야 하는 값이나, 전역적으로 공유되는 상태를 효율적으로 관리하는 데 사용된다.
상수, 개수 카운터, 설정 값 등.
애플리케이션 전체에서 사용되는 상수 값이나 전역 카운터는 객체마다 독립적으로 존재할 필요가 없다. Static 필드는 이러한 데이터를 한 번만 메모리에 할당하여 효율적으로 관리할 수 있도록 한다.

예제: 공통 카운터
public class Counter {
    static int sharedCounter = 0; // 모든 객체가 공유하는 필드

    void increment() {
        sharedCounter++;
    }
}

위 예제에서 sharedCounter는 Static 필드로 선언되어, 객체를 생성하지 않고도 클래스 이름으로 접근할 수 있다. 
모든 객체가 동일한 메모리 위치를 참조하므로, 한 객체에서 값을 변경하면 다른 객체에서도 변경된 값을 참조한다.


3. Static 메서드의 설계 의도
Static 메서드는 객체의 상태와 무관하게 동작하는 작업을 수행하기 위해 설계되었다.
예를 들어, 특정 연산을 수행하는 유틸리티 메서드나 객체와 독립적인 동작은 Static 메서드로 정의하는 것이 적합하다.
Static 메서드는 객체를 생성하지 않아도 호출할 수 있으므로, 불필요한 메모리 낭비를 줄이고 호출 방식을 단순화한다.

예제: 유틸리티 클래스
public class MathUtil {
    public static int add(int a, int b) {
        return a + b;
    }
}

위의 add 메서드는 객체의 상태와 관계없이 동작하므로, Static 메서드로 설계되었다. 이는 효율적이고 직관적인 사용을 가능하게 한다.


4. Static과 객체의 차이점
Static과 객체는 설계의 목적이 다르다. 객체는 각기 다른 상태를 관리하기 위해 설계되었으며, Static은 공통 데이터를 관리하고 객체와 독립적으로 동작하기 위해 설계되었다.

Static 필드는 모든 객체가 동일한 값을 참조하는 반면, 객체의 필드는 각기 다른 값을 가질 수 있다.
Static 메서드는 클래스 자체에서 동작하며, 객체의 상태를 참조할 수 없다. 반면, 일반 메서드는 객체의 상태를 참조하며 this 키워드를 통해 현재 객체를 조작할 수 있다.


// Static 필드
public class SharedState {
    static int sharedValue = 0;
}

// 객체 필드
public class InstanceState {
    int instanceValue = 0;
}

SharedState의 sharedValue는 모든 객체가 공유하지만, InstanceState의 instanceValue는 각 객체가 독립적으로 관리한다.


5. Static과 싱글톤의 설계 의도 비교
Static과 싱글톤은 전역적으로 데이터를 관리한다는 점에서 유사하지만, 근본적인 설계 의도는 다르다.

Static은 클래스 수준에서 공통 데이터와 유틸리티 동작을 제공하기 위해 설계되었다.
싱글톤은 단일 객체를 생성하여 상태와 동작을 관리하며, 객체 지향 설계 원칙을 유지한다.
Static은 단순히 공유 상태를 제공하지만, 싱글톤은 객체 지향적 캡슐화를 지원하며 다형성과 확장성을 제공한다.


Static의 설계 의도
공통적인 데이터를 관리하고, 객체 생성 없이 동작할 수 있는 유틸리티를 제공.

싱글톤의 설계 의도
단일 객체로 상태와 동작을 관리하며, 상속과 다형성을 지원.


예제: 싱글톤
public class SingletonExample {
    private static final SingletonExample instance = new SingletonExample();

    private SingletonExample() {} // 생성자 private

    public static SingletonExample getInstance() {
        return instance;
    }
}

위 코드에서 SingletonExample은 단일 인스턴스만 생성되어 전역적으로 상태를 관리한다.


6. Static을 사용하는 이유
Static은 객체 지향 설계에서 다음과 같은 한계를 보완한다.

공통 상태 관리: 모든 객체가 동일하게 접근해야 하는 데이터를 효율적으로 관리한다.

객체 생성 비용 절감: 객체와 무관한 작업에서 불필요한 객체 생성을 방지한다.

단순화: 클래스 자체에서 동작하는 유틸리티 메서드와 공통 데이터를 제공함으로써 코드의 가독성과 직관성을 높인다.


결론
Static은 공통 상태와 동작을 효율적으로 관리하기 위해 설계된 키워드로, 객체 지향 설계의 한계를 보완한다.
객체와 독립적으로 동작해야 하는 유틸리티 메서드와 전역적으로 공유해야 하는 데이터에서 활용되며, 객체의 상태를 독립적으로 관리해야 할 때는 적합하지 않다.
Static은 싱글톤과 유사한 역할을 수행하지만, 설계 의도와 확장성에서 차이를 가진다.
Static은 단순성과 효율성에 초점을 맞추어 설계되었으며, 적절히 활용하면 코드의 가독성과 성능을 향상시킬 수 있다.


** return
메서드 실행을 종료하고 호출한 위치로 값을 반환하거나, 반환 없이 단순히 종료하는 데 사용된다.

** break
반복문이나 switch 문을 종료하는 데 사용된다.





** 클래스 구성 코드 배치
static 상수 및 정적 변수 -> 인스턴스 변수(필드) → 생성자 → 공개 메서드(public method) → Getter/Setter → 비공개 메서드(private method)





** 생성자

객체의 일관성과 안정성 보장:
필수 필드를 초기화하여 객체의 상태가 무효 상태가 되지 않도록 보장.
잘못된 초기화를 방지하기 위해 유효성 검증을 포함할 수 있음.
즉, 딱히 관리할 필요 없는 클래스면 생성자 필요 없이 그냥 바로 객체명.필드명 등으로 접근해버리면 됨.
대신 이러면 여기저기서 접근해서 수정 및 초기화할 수 있으므로 필드 값과 상태가 불안정해진다.

캡슐화와 필드 보호:
필드 값을 외부에서 직접 설정하지 못하게 하고, 초기화 로직을 캡슐화하여 객체를 보호.

코드의 가독성과 유지보수성 향상:
생성자를 통해 객체 생성과 초기화 로직이 명확하게 정의되므로 코드의 의도가 명확해지고 유지보수가 쉬워짐.

초기화 방식의 유연성 제공:
생성자 오버로딩과 체이닝을 통해 다양한 초기화 요구를 충족하며, 선택적 데이터 초기화를 허용.

불변 객체 설계:
모든 필드를 생성자를 통해 초기화하고 이후 값을 변경하지 않도록 설계. private final
불변 객체는 멀티스레드 환경에서 안전하며, 상태 변경의 오류를 방지.



** Getter와 Setter

Getter: 객체의 필드 값을 외부에서 읽을 수 있도록 제공합니다.
Setter: 객체의 필드 값을 외부에서 수정할 수 있도록 제공합니다.

캡슐화 구현:
필드를 private으로 숨기고, getter와 setter를 통해 간접적으로 접근하도록 설계합니다.

필드 값 보호:
외부에서 필드 값을 직접 수정하지 못하게 하고, 필요한 경우 검증 로직을 통해 안전하게 변경할 수 있습니다.

유효성 검증:
setter를 통해 필드 값 설정 시, 유효성을 확인하거나 특정 조건을 강제할 수 있습니다.

데이터 읽기/쓰기 인터페이스 제공:
클래스 외부에서 필드 값을 읽고 수정할 수 있는 명확한 인터페이스를 제공합니다.


Getter만 제공:
읽기 전용 필드를 설계할 수 있습니다.
불변성을 강화하고, 데이터를 외부에서 수정하지 못하도록 제한합니다.

Setter만 제공:
필드 값을 설정만 할 수 있고 읽지는 못하도록 제한할 수 있습니다.

Getter와 Setter 모두 제공:
객체의 필드를 읽고 수정할 수 있는 유연성을 제공합니다.



** 접근 제어자

private: 모든 외부 호출을 막는다.
default(package-private): 같은 패키지안에서 호출은 허용한다.
protected: 같은 패키지안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다. 
public: 모든 외부 호출을 허용한다.

예외 : Reflection API는 setAccessible(true) 메서드를 통해 Java의 접근 제한을 우회하여 접근 제어자에 관계없이 필드나 메서드, 생성자에 접근할 수 있음.
	Spring JPA는 엔티티 클래스의 기본 생성자를  사용해서 객체를 만들어야 한다. 일반적으로 기본 생성자는 protected를 적용해둔다.
	하지만 JPA는 리플렉션을 통해 접근 제어자를 우회하여 기본 생성자를 사용한다.
	

** 자바 파일 하나에 여러개의 클래스를 선언할 수 있다.
단, public 클래스는 하나만 존재할 수 있으며, 자바 파일 명과 클래스 명이 일치해야 한다.

규칙:
public 클래스가 포함된 파일은 반드시 파일 이름과 public 클래스 이름이 동일해야 합니다.
public 클래스가 없으면, 파일 이름과 클래스 이름은 일치하지 않아도 컴파일 및 실행에 문제가 없습니다.

권장:
관례적으로 파일 이름과 클래스 이름을 동일하게 유지하는 것이 좋습니다.
한 파일에 여러 클래스를 포함해야 하는 경우, 한 파일에 한 클래스만 포함하는 방식으로 리팩토링하는 것이 가독성과 유지보수에 유리합니다.


** record
레코드 선언:

java

record something(T value) {}
아무 타입, 여러개 매개변수로 받을 수 있음.
선언된 변수는 private final 필드로 자동 생성.
인자를 통해 초기화하는 생성자 자동 생성.
편의 제공하는 메서드도 자동 생성

게터 메서드: value(), name().
toString():
equals() 및 hashCode(): 필드 값이 동일하면 true.

주요 특징:
간결한 문법으로 불변 객체를 쉽게 생성.
게터 메서드는 필드 이름과 동일하며, get 접두사 없이 사용.





** 상속

요약 : 필드와 메서드 모두 참조변수 타입 기준으로 작동. 단, 오버라이드된 메서드는 객체 타입을 기준으로 호출(런타임 동적 바인딩)

1. 컴파일 타임
참조 변수의 타입을 기준으로!
호출 가능한 메서드와 필드를 확인.
메서드가 참조 변수의 타입에서 정의되지 않았으면 컴파일 오류 발생.
필드는 참조 변수의 타입 기준으로 접근.

2. 런타임
객체의 실제 타입에 따라!
메서드 호출 시, 자식 클래스에서 오버라이드된 메서드가 있으면 그것이 호출됨(동적 바인딩).
필드 접근은 여전히 참조 변수의 타입 기준(정적 바인딩).


** 상속 - 메서드 
1. 참조 변수와 객체 타입
참조 변수 타입은 컴파일 시점에 접근 가능한 메서드와 필드를 결정.
객체 타입은 런타임에 실제로 호출되는 메서드를 결정.


2. 오버라이딩된 메서드의 호출 동작
Java에서는 동적 바인딩에 의해 오버라이딩된 메서드가 호출.

컴파일 시점: 참조 변수 타입에서 호출 가능한 메서드인지 확인.
런타임 시점: 오버라이딩된 메서드는 런타임에 객체 타입에 따라 호출됨. 이는 변수 타입과 관계없이 동적 바인딩에 의해 동작.

3. 부모 타입 변수로 자식 타입 메서드 사용 불가한 이유
컴파일러는 참조 변수 타입을 기준으로 검증:
컴파일러는 참조 변수 타입에서 선언된 메서드만 확인.
부모 클래스 타입에는 자식 클래스의 고유 메서드가 없으므로, 호출이 불가.


4. 오버라이딩된 메서드는 어떻게 사용 가능한가?
오버라이딩된 메서드는 부모 클래스 타입에 선언되어 있기 때문에 참조 변수 타입에서 호출 가능하며, 객체 타입에 따라 동작이 결정됨.

이유:
부모 클래스의 메서드는 자식 클래스에서도 동일한 시그니처로 존재(오버라이딩).
참조 변수 타입에 선언된 메서드만 호출 가능하지만, 런타임 시 객체 타입에 따라 오버라이딩된 메서드가 호출됨.
오버라이딩된 메서드는 런타임에 객체 타입에 따라 동적 바인딩되므로, 실제 객체가 자식 클래스라면 자식 메서드를 호출할 수 있음.


5. static, final, private 접근제어자 메서드는 상속 불가.
static : 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이드는 의미가 없음.
final : 변경 불가
private : 선언한 클래스 안에 숨겨져 있으므로 밖에서는 이게 있는지조차 모르고, 접근할 수 없다.




** 상속 - 필드

1. 필드 선언부
직접적으로 부모 필드를 참조하여 자식 클래스의 필드를 초기화하는 것은 불가능.
필드 선언 시점에는 부모 클래스 필드의 초기화가 보장되지 않기 때문.

간접적으로 사용하는 방법:
생성자나 인스턴스 초기화 블록에서 부모 필드를 참조하여 자식 클래스의 필드를 초기화할 수 있음.
부모 필드가 static이라면 자식 클래스 필드 선언에서 사용 가능.

추천 접근법:
부모 필드가 private일 경우, getter 메서드를 활용하여 안전하게 접근.


2. 부모 클래스의 필드를 자식 클래스의 지역변수로 사용

부모 클래스의 필드가 private가 아닌 경우, 자식 클래스에서 필드 이름만으로 접근 가능
자식 클래스에서 부모와 동일한 이름의 필드가 정의된 경우, 기본적으로 자식 클래스의 필드가 참조됨.
super 키워드를 사용하여 부모 클래스의 필드를 명시적으로 참조할 수 있음

3. private 필드는 직접 접근 불가:
부모 클래스의 private 필드는 상속되지 않으며, getter 또는 다른 접근 메서드를 통해 간접적으로 접근해야.